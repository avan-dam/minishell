GIT:
Adding amber branch to head:
git checkout amberbranch                
git add .
git commit -m"me"
git push origin amberbranch
git checkout master
git merge amberbranch
git add .
git commit -m"merging amber branch"
git push origin master
if conflicts checkout to my branch
AMBER:
SIGNAL:
https://linuxhint.com/signal_handlers_c_programming_language/


AMBER: REDIRECTION NOTES:
FIX 
echo hello 1>&2>file
echo hello > file 2>&1
echo hello 2>&1>file
echo helloha &>filey
trying to use dup2:
		else if (d == 0)
			fd = open(filename, O_RDWR|O_CREAT|O_TRUNC, 0666);
		else if (d == 1)
			fd = open(filename, O_RDWR|O_CREAT|O_APPEND, 0666);
		dup2(fd, 1);   // make stdout go to file
https://catonmat.net/bash-one-liners-explained-part-three
Operator > is the output redirection operator. Bash 
first tries to open the file for writing and if it 
succeeds it sends the stdout of command to the newly 
opened file. If it fails opening the file, the whole 
command fails.

Writing command >file is the same as writing command 
1>file. The number 1 stands for stdout, which is the 
file descriptor number for standard output.
Bash opens file and replaces file descriptor 1 with 
the file descriptor that points to file. So all the 
output that gets written to file descriptor 1 from 
now on ends up being written to file

In general you can write command n>file, which will 
redirect the file descriptor n to file.
e.g. $ ls > file_list
redirects the stderr to file. 2 stands for stderr
e.g. $ command 2> file
This one-liner uses the &> operator to redirect 
both output streams - stdout and stderr - from 
command to file. 
e.g. $ command &>file
this has same output as: $ command >file 2>&1
here  First stdout is redirected to file, and then 
stderr is duplicated to be the same as stdout. So 
both streams end up pointing to file.
When bash sees several redirections it processes 
them from left to right.

$ 2>&1 : This one duplicates file descriptor 2 to be 
a copy of file descriptor 1

$ command &>file === $ command >&file

Discard the standard output of a command
$ command > /dev/null
The special file /dev/null discards all data written to 
it.
discard both stdout and stderr by doing: 
$ command >/dev/null 2>&1
or also
$ command &>/dev/null
Suppose you want to read the first line of the file in 
a variable. You can simply do this:
$ read -r line < file
Bash's built-in read command reads a single line from 
standard input. By using the input redirection operator 
< we set it up to read the line from the file.

Redirect stderr of all commands to a file forever
exec 2>file
If you specify redirects after exec, then they will 
last forever, meaning until you change them or exit 
the script/shell.






AMBER:
- evecve!!
chmod
ls
ls -la
ls -l
awk

for double vs single quotes 
single quotes take literally so print even $
double quotes replace the dollar
- ls, cat -e, 
Amber: To Fix
echo TEST_$u==hallo$log
echo -n -n -n $potato$orange; unset 
echo 123$us$
echo $halllo### with and without hallo exported
so needs to stop at '#' '$' '-' '='
- free
export k l=o
export with no arguments

pipe vs semi colon
; execute one after the other
| combine them

External functions allowed:
- malloc
- free
- write
- open
- read
- close	
- fork
Fork system call is used for creating a new process, which is called child process, which runs concurrently 
with the process that makes the fork() call (parent process). After a new child process is created, both 
processes will execute the next instruction following the fork() system call. A child process uses the same 
pc(program counter), same CPU registers, same open files which use in the parent process.
e.g.
#include <stdio.h> 
#include <sys/types.h> 
#include <unistd.h> 
int main() 
{ 
  
    // make two process which run same 
    // program after this instruction 
    fork(); 
    printf("Hello world!\n"); 
    return 0; 
} 
outputs:
Hello world!
Hello world!

- wait
The wait() system call suspends execution of the calling process until one of its children terminates. 

- waitpid
The waitpid() system call suspends execution of the calling process until a child specified by pid argument 
has changed state. By default, waitpid() waits only for terminated children, but this behavior is modifiable 
via the options argument, as described below:
- value of PID < -1 : meaning wait for any child process whose process group ID is equal to the absolute value of pid.
- value of PID = -1 : meaning wait for any child process.
- value of PID = 0 : meaning wait for any child process whose process group ID is equal to that of the calling process.
- value of PID > 0 : meaning wait for the child whose process ID is equal to the value of pid.
more info on this...

- wait3 & wait 4
The wait3() and wait4() system calls are similar to waitpid(2), but additionally return resource usage information about 
the child in the structure pointed to by rusage.
wait3(status, options, rusage); === waitpid(-1, status, options);
wait4(pid, status, options, rusage); === waitpid(pid, status, options);
In other words, wait3() waits of any child, while wait4() can be used to select a specific child, or children, on which to wait

- signal¯¸
behaviour of signal varies across UNIX versions
Signal() sets the disposition of the signal signum to handler, which is either SIG_IGN, SIG_DFL, or the address of a 
programmer-defined function. 
If signal signum is delivered to the process then: 
    if the disposition is set to SIG_IGN, then signal is ignored
    If the disposition is set to SIG_DFL, then the default action associated with the signal occurs.
    If the disposition is set to a function, then first either the
    disposition is reset to SIG_DFL, or the signal is blocked (see
    Portability below), and then handler is called with argument
    signum.  If invocation of the handler caused the signal to be
    blocked, then the signal is unblocked upon return from the
    handler.
signal() returns the previous value of the signal handler, or SIG_ERR
on error.  In the event of an error, errno is set to indicate the
cause.

- kill
The kill() function shall send a signal to a process or a group of processes specified by pid. 
The signal to be sent is specified by sig and is either one from the list given in <signal.h> or 0. 
If sig is 0 (the null signal), error checking is performed but no signal is actually sent. 
The null signal can be used to check the validity of pid.

- exit
Terminates calling process

- getcwd
char *getcwd(char *buf, size_t size);
copies an absolute pathname of the current working directory to the array pointed to by buf, which 
is of length size.
If the length of the absolute pathname of the current working directory, including the terminating 
null byte, exceeds size bytes, NULL is returned, and errno is set to ERANGE

- chdir
int chdir(const char *path);
chdir() changes the current working directory of the calling process to the directory specified in path.
On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

- stat & lstat & fstat
return information about a file
permission is required on all of the directories in pathname that lead to the file.
lstat() is identical to stat(), except that if pathname is a symbolic
link, then it returns information about the link itself, not the file
that the link refers to.

fstat() is identical to stat(), except that the file about which
information is to be retrieved is specified by the file descriptor
fd.
retrieve information about the file pointed to by pathname
return a stat structure, which contains the
       following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };
On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

- execve
int execve(const char *pathname, char *const argv[], char *const envp[]);
execve() executes the program referred to by pathname.  This causes the program that is currently being run 
by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized 
and uninitialized) data segments.

- dup & dup2
The dup() system call creates a copy of a file descriptor.
It uses the lowest-numbered unused descriptor for the new descriptor.
If the copy is successfully created, then the original and copy file descriptors may be used interchangeably.
They both refer to the same open file description and thus share file offset and file status flags.

The dup2() system call is similar to dup() but the basic difference between them is that instead of using the 
lowest-numbered unused file descriptor, it uses the descriptor number specified by the user.

- pipe
Conceptually, a pipe is a connection between two processes, such that the standard output from one process 
becomes the standard input of the other process. Pipe is one-way communication only 

- opendir
- readdir
- closedir
- strerror
returns a pointer to a string that describes the error code passed in the argument errnum

- erno
references:
https://linux.die.net/
https://www.geeksforgeeks.org/
https://man7.org/


BASH MANUAL:
https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html
Shell Syntax:
When the shell reads input, it proceeds through a sequence of operations. If the input indicates the beginning of a 
comment, the shell ignores the comment symbol (‘#’), and the rest of that line.
Otherwise, roughly speaking, the shell reads its input and divides the input into words and operators, employing the 
quoting rules to select which meanings to assign various words and characters.
The shell then parses these tokens into commands and other constructs, removes the special meaning of certain words 
or characters, expands others, redirects input and output as needed, executes the specified command, waits for the 
command’s exit status, and makes that exit status available for further inspection or processing

Shell Operation
The following is a brief description of the shell’s operation when it reads and executes a command. Basically, 
the shell does the following:

Reads its input from a file (see Shell Scripts), from a string supplied as an argument to the -c invocation option 
(see Invoking Bash), or from the user’s terminal.
Breaks the input into words and operators, obeying the quoting rules described in Quoting. These tokens are separated 
by metacharacters. Alias expansion is performed by this step (see Aliases).
Parses the tokens into simple and compound commands (see Shell Commands).
Performs the various shell expansions (see Shell Expansions), breaking the expanded tokens into lists of filenames 
(see Filename Expansion) and commands and arguments.
Performs any necessary redirections (see Redirections) and removes the redirection operators and their operands 
from the argument list.
Executes the command (see Executing Commands).
Optionally waits for the command to complete and collects its exit status (see Exit Status).

Quoting:
• Escape Character:	  	How to remove the special meaning from a single character.
A non-quoted backslash ‘\’ is the Bash escape character. It preserves the literal value of the next character that 
follows, with the exception of newline. If a \newline pair appears, and the backslash itself is not quoted, 
the \newline is treated as a line continuation (that is, it is removed from the input stream and effectively ignored).
• Single Quotes:	  	How to inhibit all interpretation of a sequence of characters.
(‘'’) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes,
even when preceded by a backslash.
• Double Quotes:	  	How to suppress most of the interpretation of a sequence of characters.
preserves the literal value of all characters within the quotes, with the exception of ‘$’, ‘`’, ‘\’, and with a couple
of more specific examples.
• ANSI-C Quoting:	  	How to expand ANSI-C sequences in quoted strings.
Words of the form $'string' are treated specially. The word expands to string, with backslash-escaped characters replaced 
as specified by the ANSI C standard. Backslash escape sequences, if present, are decoded specifically
• Locale Translation:	  	How to translate strings into different languages.
A double-quoted string preceded by a dollar sign (‘$’) will cause the string to be translated according to the current 
locale. If the current locale is C or POSIX, the dollar sign is ignored. If the string is translated and replaced, the 
replacement is double-quoted.

RETURN OF SIMPLE COMMANDS:
The return status (see Exit Status) of a simple command is its exit status as provided by the POSIX 1003.1 waitpid 
function, or 128+n if the command was terminated by signal n.

Pipelines:
A pipeline is a sequence of one or more commands separated by one of the control operators ‘|’ or ‘|&’.
The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each 
command reads the previous command’s output. 
If ‘|&’ is used, command1’s standard error, in addition to its standard output, is connected to command2’s 
standard input through the pipe;\Lists of Commands
LISTS OF COMMANDS:
A list is a sequence of one or more pipelines separated by one of the operators ‘;’, ‘&’, ‘&&’, or ‘||’, and 
optionally terminated by one of ‘;’, ‘&’, or a newline.
Of these list operators, ‘&&’ and ‘||’ have equal precedence, followed by ‘;’ and ‘&’, which have equal precedence.
A sequence of one or more newlines may appear in a list to delimit commands, equivalent to a semicolon.
Commands separated by a ‘;’ are executed sequentially; the shell waits for each command to terminate in turn. 
The return status is the exit status of the last command executed.
AND and OR lists are sequences of one or more pipelines separated by the control operators ‘&&’ and ‘||’, 
respectively. AND and OR lists are executed with left associativity.
command1 || command2    === command2 is executed if, and only if, command1 returns a non-zero exit status.

Pattern Matching:
The special pattern characters have the following meanings:
* : Matches any string, including the null string. 
? : Matches any single character
[…] : Matches any one of the enclosed characters. 

Quote Removal:
After the preceding expansions, all unquoted occurrences of the characters ‘\’, ‘'’, and ‘"’ that did not result 
from one of the above expansions are removed.

Redirections:
Before a command is executed, its input and output may be redirected using a special notation interpreted by the 
shell. Redirection allows commands’ file handles to be duplicated, opened, closed, made to refer to different 
files, and can change the files the command reads from and writes to. Redirection may also be used to modify 
file handles in the current shell execution environment. Redirections are processed in the order they appear, 
from left to right.
Each redirection that may be preceded by a file descriptor number may instead be preceded by a word of the form 
{varname}. 
In the following descriptions, if the file descriptor number is omitted, and the first character of the redirection 
operator is ‘<’, the redirection refers to the standard input (file descriptor 0). If the first character of the 
redirection operator is ‘>’, the redirection refers to the standard output (file descriptor 1).
Bash handles several filenames specially when they are used in redirection:
-   /dev/fd/fd : If fd is a valid integer, file descriptor fd is duplicated.
-   /dev/stdin : File descriptor 0 is duplicated.
-   /dev/stdout : File descriptor 1 is duplicated.
-   /dev/stderr : File descriptor 2 is duplicated.
-   /dev/tcp/host/port : If host is a valid hostname or Internet address, and port is an integer port number or 
    service name, Bash attempts to open the corresponding TCP socket.
-   /dev/udp/host/port : If host is a valid hostname or Internet address, and port is an integer port number or 
    service name, Bash attempts to open the corresponding UDP socket.
A failure to open or create a file causes the redirection to fail.
Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file 
descriptors the shell uses internally.

Redirecting Input:
Redirection of input causes the file whose name results from the expansion of word to be opened for reading on 
file descriptor n, or the standard input (file descriptor 0) if n is not specified.
e.g. [n]<word

Redirecting Output:
Redirection of output causes the file whose name results from the expansion of word to be opened for writing on 
file descriptor n, or the standard output (file descriptor 1) if n is not specified. If the file does not exist 
it is created; if it does exist it is truncated to zero size.
e.g. [n]>[|]word

Appending Redirected Output
Redirection of output in this fashion causes the file whose name results from the expansion of word to be opened 
for appending on file descriptor n, or the standard output (file descriptor 1) if n is not specified. If the file 
does not exist it is created.
e.g. [n]>>word
